# Rule Type: Always
# B2B Platform - Project Rules for Cursor

## Overview

- Purpose: B2B-платформа с личным кабинетом модератора, парсингом сайтов поставщиков и интеграцией с Checko.
- Stack:
  - Backend: FastAPI, PostgreSQL, SQLAlchemy, Pydantic v2
  - Frontend: Next.js (App Router), TypeScript, Tailwind, Shadcn UI
  - Parser Service: Python, Chrome CDP (Playwright)
- Key docs: OVERVIEW.md, README.md, DOCUMENTATION_INDEX.md

Перед любыми изменениями:
1) Найди и прочитай OVERVIEW.md и README.md.
2) Если задача затрагивает конкретную часть (frontend/backend/parser), прочитай соответствующий раздел документации.

## ⚠️ ВАЖНО: Организация файлов

**ЗАПРЕЩЕНО:**
- Создавать временные файлы и скрипты в корне проекта
- Создавать тестовые файлы для проверки гипотез в основных директориях
- Засорять проект временными файлами (test.py, check.py, temp.py и т.д.)

**ОБЯЗАТЕЛЬНО:**
- Все временные скрипты, проверки гипотез, тестовые файлы создавать в отдельной папке `temp/` или `experiments/`
- Временные файлы должны быть четко отделены от основного кода проекта
- После завершения работы с временными файлами - удалять их или перемещать в архив

**НЕ УСТРАИВАТЬ ПОМОЙКУ В ПРОЕКТЕ!**

## Architecture Principles

- Три отдельных сервиса:
  - `backend/` — API и бизнес-логика.
  - `frontend/moderator-dashboard-ui/` — личный кабинет модератора.
  - `parser_service/` — парсинг через Chrome CDP.
- Не перемешивать ответственность между сервисами.
- Сначала описывать/уточнять архитектурные изменения текстом, потом менять код.

## Backend Rules (FastAPI)

- Основные директории:
  - `app/transport/routers` — только FastAPI endpoints.
  - `app/usecases` — бизнес-логика.
  - `app/adapters` — внешние сервисы (Parser Service, Checko, Ollama).
  - `app/db` — модели и работа с БД.
- Запрещено:
  - Писать SQL и сложную логику прямо в роутерах.
  - Менять структуру таблиц без миграций.
  - Переименовывать поля DTO без обновления Pydantic-схем и TS-типов фронта.
- Перед изменением эндпоинтов:
  - Открой `/docs` и посмотри, какие маршруты уже существуют.
  - Не ломай существующие URL без явного запроса.

## Frontend Rules (Next.js)

- Все HTTP-запросы идут через `frontend/moderator-dashboard-ui/lib/api.ts`.
- Нельзя вызывать `fetch("http://...")` напрямую из компонентов.
- Страницы модератора живут в `app/...` и соответствуют backend endpoint'ам.
- При изменении API:
  - Обновить `lib/api.ts`.
  - Обновить `lib/types.ts`.
  - Обновить соответствующие страницы/компоненты.

## Parser Service & AI

- Parser Service отвечает за:
  - поиск URL (Google/Yandex),
  - работу с Chrome CDP,
  - первичный парсинг HTML.
- Backend взаимодействует с Parser Service через HTTP‑клиент в `app/adapters`.
- Логика AI (Ollama, Qwen) живёт в:
  - `app/adapters/ollama_client.py`
  - `app/services/ai_extractor.py`
- Нельзя:
  - вызывать Chrome CDP напрямую из Backend,
  - дублировать AI‑логику в разных местах.

## Change Workflow

- Делай изменения маленькими порциями: один модуль, один endpoint, одна страница.
- После каждого шага:
  - Backend: убедись, что `uvicorn app.main:app` стартует без ошибок.
  - Frontend: убедись, что `next dev` или `npm run build` проходит.
- Если изменение вызывает 404/500:
  - Не добавляй новый код поверх.
  - Покажи diff и предложи откат/исправление вместо усложнения.

## When Unsure

Если ты не уверен:
- где разместить файл,
- как назвать endpoint,
- как связаны слои,

СНАЧАЛА задай уточняющие вопросы пользователю и НЕ пиши код, основанный на догадках.

## Validation & Done Definition

Перед тем как заявлять, что задача выполнена и решение «готово и работает», ты ОБЯЗАН:

1. Явно перечислить, какие файлы ты изменил и зачем.
2. Описать, КАК проверить решение (конкретные команды и шаги).

### Backend (FastAPI)

Для любых изменений в backend ты ДОЛЖЕН:

- Проверить, что приложение стартует:
  - команда: `cd backend` затем `uvicorn app.main:app --reload`
- Если добавлены/изменены эндпоинты:
  - ПРЕДЛОЖИТЬ пользователю протестировать их через `http://127.0.0.1:8000/docs`
  - и/или привести пример запроса:
    - команда: `curl "http://127.0.0.1:8000/..."`

Не пиши, что «всё работает», если:
- ты не показал команды для проверки,
- потенциально требуются миграции БД, но ты не описал, как их применить.

### Frontend (Next.js)

Для любых изменений во frontend ты ДОЛЖЕН:

- Проверить, что проект собирается:
  - команда: `cd frontend/moderator-dashboard-ui`
  - `npm run lint`
  - `npm run build` или `npm run dev`
- Если изменялся вызов API или страница:
  - указать, какой URL в браузере нужно открыть (например, `/parsing-runs/[runId]`)
  - и какой результат ожидается (без 404/500).

Нельзя писать «готово», пока ты не описал проверку сборки и ручной тест.

### Parser Service / AI

Если ты менял Parser Service или AI-интеграцию:

- Приведи команды для запуска всех сервисов в правильном порядке:
  1. Chrome CDP
  2. Parser Service
  3. Backend
  4. Frontend
- Приведи пример запроса, который демонстрирует работу:
  - пример `POST /parse` или `POST /ai/extract-from-url` с телом и ожидаемым ответом.

### Общий критерий "Задача завершена"

Задача считается завершённой, только если ты:

1. Описал все изменения.
2. Привёл точные команды для проверки (backend, frontend, parser/AI — по необходимости).
3. Описал, какой результат должен увидеть пользователь (URL, статус, важные поля ответа).
4. Указал возможные ограничения (что ещё НЕ сделано или требует дальнейшей настройки).

Если какой‑то из этих пунктов не выполнен — не говори, что задача закрыта, а явно напиши, что решение ТРЕБУЕТ проверки пользователем.

## Изменение существующих файлов (Safe Editing)

При работе с ВАЖНЫМИ файлами (роуты, usecases, adapters, db‑модели, api.ts, types.ts) действую ТАК:

1. Сначала ЧИТАЮ файл и КРАТКО формулирую, что он делает.
2. В ответе описываю ПЛАН изменений (списком), не меняя код.
3. ЖДУ подтверждения пользователя на план, если изменения затрагивают:
   - структуру БД,
   - существующие API‑эндпоинты,
   - общие типы DTO,
   - ключевые компоненты фронта.

Запрещено:
- Переписывать файл «целиком с нуля», если можно внести локальные изменения.
- Удалять блоки кода, если не уверен, что они не используются.
- Переименовывать функции/классы/поля, не проверив все места использования.

## Экспериментальные изменения через копию

Если предложенное решение НЕ очевидно рабочее (нужно проверить гипотезу, есть риск сломать существующий сценарий), то:

1. НЕ изменяю оригинальный файл напрямую.
2. Делаю копию РЯДОМ, в temp/ или experiments/, с понятным именем:

   - `temp/backend/experiments/new_parsing_flow.py`
   - `temp/frontend/experiments/new_supplier_detail.tsx`

3. В ответе явно пишу:
   - какой файл является ОРИГИНАЛОМ,
   - где лежит ЭКСПЕРИМЕНТАЛЬНАЯ версия,
   - как её можно подключить/протестировать.

Только после того, как пользователь подтвердит, что экспериментальная версия работает, можно:
- аккуратно перенести изменения в основной файл,
- удалить временный эксперимент.

## Критические точки — трогаю только по прямому запросу

К критически важным файлам относятся:

- `backend/app/transport/routers/*` — существующие эндпоинты
- `backend/app/usecases/*` — ключевая бизнес-логика
- `backend/app/adapters/db/models.py` и миграции
- `frontend/moderator-dashboard-ui/lib/api.ts`
- `frontend/moderator-dashboard-ui/lib/types.ts`

Правило:
- НЕ менять сигнатуры, пути, названия полей и типов в этих файлах,
  если пользователь явно не просил именно это.
- Если для задачи всё-таки нужно изменить критический файл —
  сначала описать, ЧТО именно изменится и КАКИЕ части приложения это затронет.

## Сохранение старой реализации

Если нужно значительно изменить функцию/класс/компонент:

1. НЕ переписываю существующую реализацию поверх.
2. Сохраняю старую версию под новым именем, например:
   - `old_get_parsing_status`
   - `SupplierDetailLegacy`
3. Новую версию пишу РЯДОМ, с новым именем.
4. В комментарии кратко объясняю:
   - чем новая версия отличается,
   - как при необходимости вернуть старую.

Пользователь сам решает, когда удалить legacy‑реализацию.

## Напоминание про безопасность изменений

Перед тем как утверждать, что «решение готово и работает», я:

- НЕ удаляю/не ломаю старый код без бэкапа или альтернативы.
- Даю команды для запуска и проверки (backend/frontend/parser).
- Ясно описываю, что именно нужно проверить вручную.
- Не говорю, что всё работает, пока не проверено согласно разделу "Validation & Done Definition".

## История действий и отсутствие повторов

Для КАЖДОЙ задачи я обязан вести mini‑лог своих действий и ссылаться на него, чтобы не повторять одно и то же.

### Что я фиксирую

В конце каждого большого шага (ответа) я кратко перечисляю:

1. **Что было сделано**
   - изменённые файлы (с путями),
   - добавленные/удалённые файлы,
   - ключевые функции/эндпоинты, которые трогал.

2. **Что НЕ сработало**
   - какие подходы/гипотезы пробовал и ОТКАЗАЛСЯ использовать,
   - какие идеи показали себя нерабочими и почему.

3. **Статус задачи**
   - что уже решено,
   - что ещё осталось сделать,
   - какие риски/неясности остались.

Пример формата:

- Сделано:
  - `backend/app/transport/routers/parsing.py`: добавлен endpoint `GET /parsing-runs/{run_id}`.
  - `frontend/.../lib/api.ts`: добавлен метод `getParsingRun(runId)`.
- Не сработало:
  - Пытался получить данные напрямую из Parser Service — отказался, оставил через Backend.
- Осталось:
  - Добавить UI для отображения ошибок.

### Правило против повторов

Перед тем как предлагать новый план или менять код, я ОБЯЗАН:

1. Просмотреть свой предыдущий mini‑лог по этой задаче.
2. НЕ предлагать снова:
   - уже отвергнутые подходы,
   - уже сделанные, но не проверенные изменения.
3. Если повтор всё‑таки нужен (например, пользователь попросил вернуться к старой идее) —
   явно указать: «Это повтор предыдущего шага по просьбе пользователя».

Запрещено:

- Предлагать один и тот же рефакторинг/подход несколько раз подряд, не ссылаясь на предыдущие попытки.
- «Забывать», какие файлы уже менялись в рамках текущей задачи.

## Использование терминала

У тебя есть доступ к встроенному терминалу Cursor Agent.

- Всегда, когда для решения задачи можно что‑то проверить или выполнить через терминал
  (запуск сервиса, тесты, curl‑запрос, проверка порта, просмотр логов и т.п.),
  ВЫПОЛНЯЙ эти команды САМ через терминал, а не проси пользователя сделать это.

- В ответе показывай:
  - какие команды были запущены;
  - кратко к чему они привели (успех / ошибка, важные строки вывода).

- Не пиши, что «всё готово» или «должно работать», если ты мог выполнить проверку через терминал,
  но не сделал этого.

## Git и страховка перед крупными изменениями

Перед любыми крупными изменениями (рефакторинг модулей, изменение схемы БД, массовые правки фронта):

- Убедись, что рабочее состояние закоммичено в Git.
- Если в проекте ещё нет Git, предложи инициализировать его и настроить .gitignore.
- Не выполняй опасные изменения, если в дереве есть незакоммиченные файлы, о которых пользователь ничего не говорил.

## Документирование ошибок и решений (БИБЛИЯ)

**⚠️ КРИТИЧЕСКИ ВАЖНО: Все ошибки и их решения ОБЯЗАТЕЛЬНО документируются и являются "НЕПРИКОСНОВЕННЫМИ, КАК БИБЛИЯ".**

### Правила документирования:

1. **Каждая ошибка ДОЛЖНА быть задокументирована:**
   - В файле `docs/TROUBLESHOOTING.md` (основной документ "Библия ошибок")
   - С полным описанием проблемы, причины, решения и проверки
   - С указанием даты решения и измененных файлов

2. **Решения НЕ ДОЛЖНЫ быть удалены:**
   - Даже если кажется, что проблема больше не актуальна
   - Даже если код изменился и решение выглядит устаревшим
   - Решения могут быть помечены как "устаревшие", но НЕ удалены

3. **Перед решением новой ошибки:**
   - ОБЯЗАТЕЛЬНО проверь `docs/TROUBLESHOOTING.md`
   - Если похожая ошибка уже была решена - используй существующее решение
   - Если решение не подходит - документируй новое решение рядом со старым

4. **Формат документации ошибки:**
   ```
   ## Ошибка N: [Название]
   
   ### Описание проблемы
   - Что происходит
   - Какие ошибки видны
   - Где возникает
   
   ### Причина
   - Почему это происходит
   - Что вызывает проблему
   
   ### Решение
   - Пошаговое решение
   - Код изменений
   - Команды для применения
   
   ### Проверка
   - Команды для проверки
   - Ожидаемый результат
   
   ### Измененные файлы
   - Список файлов с изменениями
   
   ### Дата решения
   YYYY-MM-DD
   ```

5. **При изменении кода, связанного с задокументированной ошибкой:**
   - Проверь, не ломает ли изменение существующее решение
   - Если решение нужно обновить - обнови документацию, но сохрани старую версию как "Устаревшее решение"

6. **Запрещено:**
   - Удалять разделы с решениями ошибок
   - Изменять решения без обновления документации
   - Игнорировать существующие решения при повторении ошибки

